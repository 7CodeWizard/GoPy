// Copyright 2015 The go-python Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package bind

import (
	"fmt"
	"go/token"
	"go/types"
	"strings"
)

const (
	goPreamble = `// Package main is an autogenerated binder stub for package %[1]s.
// gopy gen -lang=go %[1]s
//
// File is generated by gopy gen. Do not edit.
package main

//#cgo pkg-config: %[2]s --cflags --libs
//#include <stdlib.h>
//#include <stdint.h>
//#include <string.h>
//#include <complex.h>
import "C"

import (
	"fmt"
	"unsafe"

	"github.com/go-python/gopy/bind/seq"
	
	%[3]s
)

var (
	_ = unsafe.Pointer(nil)
	_ = fmt.Sprintf
	_ = seq.Delete
)

// --- begin cgo helpers ---

//export _cgopy_ErrorIsNil
func _cgopy_ErrorIsNil(err error) bool {
	return err == nil
}

//export _cgopy_ErrorString
func _cgopy_ErrorString(err error) *C.char {
	return C.CString(err.Error())
}

// --- end cgo helpers ---

func init() {
	// make sure cgo is used and cgo hooks are run
	str := C.CString(%[1]q)
	C.free(unsafe.Pointer(str))
}
`
)

type goReg struct {
	Descriptor string
	ID         uint32
	Func       string
}

type goGen struct {
	*printer

	fset *token.FileSet
	pkg  *Package
	lang int // python's version API (2 or 3)
	err  ErrorList

	regs []goReg
}

func (g *goGen) gen() error {

	g.genPreamble()

	// create a Cgo hook for empty packages
	g.genPackage()

	// process slices, arrays, ...
	for _, n := range g.pkg.syms.names() {
		sym := g.pkg.syms.sym(n)
		if !sym.isType() {
			continue
		}
		g.genType(sym)
	}

	for _, s := range g.pkg.structs {
		g.genStruct(s)
	}

	// expose ctors at module level
	for _, s := range g.pkg.structs {
		for _, ctor := range s.ctors {
			g.genFunc(ctor)
		}
	}

	for _, f := range g.pkg.funcs {
		g.genFunc(f)
	}

	for _, c := range g.pkg.consts {
		g.genConst(c)
	}

	for _, v := range g.pkg.vars {
		g.genVar(v)
	}

	g.Printf("func init() {\n")
	g.Indent()

	for _, reg := range g.regs {
		g.Printf(
			"seq.Register(%[1]q, %[2]d, cgo_func_%[3]s)\n",
			reg.Descriptor,
			reg.ID,
			reg.Func,
		)
	}
	g.Outdent()
	g.Printf("}\n\n")

	g.Printf("// buildmode=c-shared needs a 'main'\nfunc main() {}\n")
	if len(g.err) > 0 {
		return g.err
	}

	return nil
}

func (g *goGen) genPackage() {
	g.Printf("\n//export cgo_pkg_%[1]s_init\n", g.pkg.Name())
	g.Printf("func cgo_pkg_%[1]s_init() {}\n\n", g.pkg.Name())
	g.Printf("const cgopy_seq_pkg_DESCRIPTOR string = %q\n\n", g.pkg.ImportPath())

}

func (g *goGen) genConst(o Const) {
	g.genFuncGetter(o.f, o, o.sym)
	g.genFunc(o.f)
	return
}

func (g *goGen) genVar(o Var) {
	fget := Func{
		pkg:       o.pkg,
		sig:       newSignature(o.pkg, nil, nil, []*Var{&o}),
		typ:       nil,
		name:      o.Name(),
		generated: true,
		id:        o.id + "_get",
		doc:       o.doc,
		ret:       o.GoType(),
		err:       false,
	}
	g.genFuncGetter(fget, &o, o.sym)
	g.genFunc(fget)

	fset := Func{
		pkg:       o.pkg,
		sig:       newSignature(o.pkg, nil, []*Var{&o}, nil),
		typ:       nil,
		name:      o.Name(),
		generated: true,
		id:        o.id + "_set",
		doc:       o.doc,
		ret:       nil,
		err:       false,
	}
	g.genFuncSetter(fset, &o, o.sym)
	g.genFunc(fset)
}

func (g *goGen) genPreamble() {
	n := g.pkg.pkg.Name()
	pkgimport := fmt.Sprintf("%q", g.pkg.pkg.Path())
	if g.pkg.n == 0 {
		pkgimport = fmt.Sprintf("_ %q", g.pkg.pkg.Path())
	}

	pkgcfg, err := getPkgConfig(g.lang)
	if err != nil {
		panic(err)
	}

	g.Printf(goPreamble, n, pkgcfg, pkgimport)
}

func (g *goGen) tupleString(tuple []*Var) string {
	n := len(tuple)
	if n <= 0 {
		return ""
	}

	str := make([]string, 0, n)
	for _, v := range tuple {
		n := v.Name()
		//typ := v.GoType()
		sym := v.sym
		//str = append(str, n+" "+qualifiedType(typ))
		tname := sym.cgotypename()
		str = append(str, n+" "+tname)
	}

	return strings.Join(str, ", ")
}

func (g *goGen) genRead(valName, seqName string, T types.Type) {
	if isErrorType(T) {
		g.Printf("%s := %s.ReadError()\n", valName, seqName)
		return
	}

	switch T := T.(type) {
	case *types.Basic:
		g.Printf("%s := %s.Read%s()\n", valName, seqName, g.seqType(T))

	case *types.Named:
		switch u := T.Underlying().(type) {
		case *types.Interface, *types.Pointer, *types.Struct,
			*types.Array, *types.Slice:
			g.Printf(
				"%[2]s := %[1]s.ReadRef().(*%[3]s)\n",
				seqName, valName,
				g.pkg.syms.symtype(T).gofmt(),
			)
		case *types.Basic:
			g.Printf("%[3]s := %[1]s.Read%[2]s();\n", seqName, seqType(u), valName)
		default:
			panic(fmt.Errorf("unsupported, direct named type %s: %s", T, u))
		}
	default:
		panic(fmt.Errorf("gopy: unhandled type %#T", T))
	}
}

func (g *goGen) genWrite(valName, seqName string, T types.Type) {
	if isErrorType(T) {
		g.Printf("if %s == nil {\n", valName)
		g.Printf("\t%s.WriteString(\"\");\n", seqName)
		g.Printf("} else {\n")
		g.Printf("\t%s.WriteString(%s.Error());\n", seqName, valName)
		g.Printf("}\n")
		return
	}
	switch T := T.(type) {
	case *types.Pointer:
		// TODO(crawshaw): test *int
		// TODO(crawshaw): test **Generator
		switch T := T.Elem().(type) {
		case *types.Named:
			obj := T.Obj()
			if obj.Pkg() != g.pkg.pkg {
				panic(fmt.Errorf("type %s not defined in package %s", T, g.pkg))
				return
			}
			g.Printf("%s.WriteGoRef(%s)\n", seqName, valName)
		default:
			panic(fmt.Errorf("unsupported type %s", T))
		}
	case *types.Named:
		switch u := T.Underlying().(type) {
		case *types.Interface, *types.Pointer, *types.Struct,
			*types.Array, *types.Slice:
			g.Printf("%s.WriteGoRef(%s)\n", seqName, valName)
		case *types.Basic:
			g.Printf("%s.Write%s(%s);\n", seqName, seqType(u), valName)
		default:
			panic(fmt.Errorf("unsupported, direct named type %s: %s", T, u))
		}
	default:
		g.Printf("%s.Write%s(%s);\n", seqName, seqType(T), valName)
	}
}

func (g *goGen) seqType(typ types.Type) string {
	return seqType(typ)
}

// seqType returns a string that can be used for reading and writing a
// type using the seq library.
// TODO(hyangah): avoid panic; gobind needs to output the problematic code location.
func seqType(t types.Type) string {
	if isErrorType(t) {
		return "String"
	}
	switch t := t.(type) {
	case *types.Basic:
		switch t.Kind() {
		case types.Bool:
			return "Bool"
		case types.Int:
			return "Int"
		case types.Int8:
			return "Int8"
		case types.Int16:
			return "Int16"
		case types.Int32:
			return "Int32"
		case types.Int64:
			return "Int64"
		case types.Uint8: // Byte.
			// TODO(crawshaw): questionable, but vital?
			return "Byte"
		case types.Uint:
			return "Uint"
		case types.Uint16:
			return "Uint16"
		case types.Uint32:
			return "Uint32"
		case types.Uint64:
			return "Uint64"
		// TODO(crawshaw): case types.Uint, types.Uint16, types.Uint32, types.Uint64:
		case types.Float32:
			return "Float32"
		case types.Float64:
			return "Float64"
		case types.String:
			return "String"
		default:
			// Should be caught earlier in processing.
			panic(fmt.Sprintf("unsupported basic seqType: %s", t))
		}
	case *types.Named:
		switch u := t.Underlying().(type) {
		case *types.Interface:
			return "Ref"
		case *types.Basic:
			return seqType(u)
		default:
			panic(fmt.Sprintf("unsupported named seqType: %s / %T", u, u))
		}
	case *types.Slice:
		switch e := t.Elem().(type) {
		case *types.Basic:
			switch e.Kind() {
			case types.Uint8: // Byte.
				return "ByteArray"
			default:
				panic(fmt.Sprintf("unsupported seqType: %s(%s) / %T(%T)", t, e, t, e))
			}
		default:
			panic(fmt.Sprintf("unsupported seqType: %s(%s) / %T(%T)", t, e, t, e))
		}
	// TODO: let the types.Array case handled like types.Slice?
	case *types.Pointer:
		if _, ok := t.Elem().(*types.Named); ok {
			return "Ref"
		}
		panic(fmt.Sprintf("not supported yet, pointer type: %s / %T", t, t))

	default:
		panic(fmt.Sprintf("unsupported seqType: %s / %T", t, t))
	}
}
